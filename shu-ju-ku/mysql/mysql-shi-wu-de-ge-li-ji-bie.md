# MySQL事务的隔离级别

## MySQL事务的隔离级别

MySQL的事务隔离级别一共有四个，分别是**读未提交**、**读已提交**、**可重复读**以及**可串行化**。

MySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。

隔离级别比较：可串行化>可重复读>读已提交>读未提交

隔离级别对性能的影响比较：可串行化>可重复读>读已提交>读未提交

由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。

## 测试数据准备

```
mysql> create table city(
    -> id int(10) auto_increment,
    -> name varchar(30),
    -> primary key (id)
    -> )engine=innodb charset=utf8mb4;

insert into city(name) values('武汉市');

mysql> select * from city;
+----+-----------+
| id | name |
+----+-----------+
| 1 | 武汉市 |
+----+-----------+
```

## 事务并发可能出现的问题

### 脏读（**Dirty Read**）

> 一个事务读到了另一个未提交事务修改过的数据

|   | 事务A                                                          | 事务B                                        |   |
| - | ------------------------------------------------------------ | ------------------------------------------ | - |
| 1 | begin;                                                       |                                            |   |
| 2 |                                                              | begin;                                     |   |
| 3 |                                                              | update city set name='温州市'  where  id = 1; |   |
| 4 | <p>select name from city where id =1;<br>读取的记录为温州市，出现了脏读</p> |                                            |   |
| 5 | commit;                                                      |                                            |   |
| 6 |                                                              | rollback;                                  |   |

{% hint style="info" %}
会话B开启一个事务，把id=1的name为武汉市修改成温州市，此时另外一个会话A也开启一个事务，读取id=1的name，此时的查询结果为温州市，会话B的事务最后回滚了刚才修改的记录，这样会话A读到的数据是不存在的，这个现象就是脏读。（脏读只在读未提交隔离级别才会出现）
{% endhint %}

### **不可重复读（Non-Repeatable Read）**

> 一个事务只能读到另一个已经提交事务修改过的数据，并且其他事务对该数据每进行一次修改并提交后，该事务都能查询到最新值。（不可重复读在读未提交和读已提交隔离级别都可能会出现）

|   | 事务A                                                               | 事务B                                        |
| - | ----------------------------------------------------------------- | ------------------------------------------ |
| 1 | begin;                                                            |                                            |
| 2 | <p>select name from city where id = 1;<br>读取的记录为武汉市</p>           |                                            |
| 3 |                                                                   | update city set name='温州市'  where  id = 1; |
| 4 | <p>select name from city where id = 1;<br>读取的记录为温州市，此时出现不可重复度</p> |                                            |
| 5 |                                                                   | update city set name='杭州市'  where  id = 1; |
| 6 | <p>select name from city where id = 1;<br>读取的记录为杭州市，此时出现不可重复度</p> |                                            |
| 7 | commit ;                                                          |                                            |

{% hint style="info" %}
会话A开启一个事务，查询id=1的结果，此时查询的结果name为武汉市。接着会话B把id=1的name修改为温州市（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），此时会话A的事务再一次查询id=1的结果，读取的结果name为温州市。会话B再此修改id=1的name为杭州市，会话A的事务再次查询id=1，结果name的值为杭州市，这种现象就是不可重复读。
{% endhint %}

### **幻读（Phantom）**

> 一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。（幻读在读未提交、读已提交、可重复读隔离级别都可能会出现）

|   | 事务A                                                              | 事务B                                    |
| - | ---------------------------------------------------------------- | -------------------------------------- |
| 1 | begin;                                                           |                                        |
| 2 | <p>select name from city where id > 1;<br>读取的记录为武汉市</p>          |                                        |
| 3 |                                                                  | insert into city(name) values ('温州市'); |
| 4 | <p>select name from city where id > 1;<br>读取的记录为武汉市和温州市，出现幻读</p> |                                        |
| 5 | commit;                                                          |                                        |

{% hint style="info" %}
会话A开启一个事务，查询id>0的记录，此时会查到name=武汉市的记录。接着会话B插入一条name=温州市的数据（隐式事务，因为此时的autocommit为1，每条SQL语句执行完自动提交），这时会话A的事务再以刚才的查询条件（id>0）再一次查询，此时会出现两条记录（name为武汉市和温州市的记录），这种现象就是幻读。
{% endhint %}



