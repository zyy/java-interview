# MySQL事务的隔离级别

### MySQL事务的隔离级别

MySQL的事务隔离级别一共有四个，分别是**读未提交**、**读已提交**、**可重复读**以及**可串行化**。

MySQL的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。

隔离级别比较：可串行化>可重复读>读已提交>读未提交

隔离级别对性能的影响比较：可串行化>可重复读>读已提交>读未提交

由此看出，隔离级别越高，所需要消耗的MySQL性能越大（如事务并发严重性），为了平衡二者，一般建议设置的隔离级别为可重复读，MySQL默认的隔离级别也是可重复读。

### 测试数据准备

```
mysql> create table city(
    -> id int(10) auto_increment,
    -> name varchar(30),
    -> primary key (id)
    -> )engine=innodb charset=utf8mb4;

insert into city(name) values('武汉市');

mysql> select * from city;
+----+-----------+
| id | name |
+----+-----------+
| 1 | 武汉市 |
+----+-----------+
```

### 事务并发可能出现的问题

#### 脏读（**Dirty Read**）

> 一个事务读到了另一个未提交事务修改过的数据

|   | 事务A                                                          | 事务B                                        |   |
| - | ------------------------------------------------------------ | ------------------------------------------ | - |
| 1 | begin;                                                       |                                            |   |
| 2 |                                                              | begin;                                     |   |
| 3 |                                                              | update city set name='温州市'  where  id = 1; |   |
| 4 | <p>select name from city where id =1;<br>读取的记录为温州市，出现了脏读</p> |                                            |   |
| 5 | commit;                                                      |                                            |   |
| 6 |                                                              | rollback;                                  |   |

{% hint style="info" %}
会话B开启一个事务，把id=1的name为武汉市修改成温州市，此时另外一个会话A也开启一个事务，读取id=1的name，此时的查询结果为温州市，会话B的事务最后回滚了刚才修改的记录，这样会话A读到的数据是不存在的，这个现象就是脏读。（脏读只在读未提交隔离级别才会出现）
{% endhint %}



